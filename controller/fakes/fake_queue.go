// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"
	"time"

	"k8s.io/client-go/util/workqueue"
)

type FakeRateLimitingInterface struct {
	AddStub        func(interface{})
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 interface{}
	}
	AddAfterStub        func(interface{}, time.Duration)
	addAfterMutex       sync.RWMutex
	addAfterArgsForCall []struct {
		arg1 interface{}
		arg2 time.Duration
	}
	AddRateLimitedStub        func(interface{})
	addRateLimitedMutex       sync.RWMutex
	addRateLimitedArgsForCall []struct {
		arg1 interface{}
	}
	DoneStub        func(interface{})
	doneMutex       sync.RWMutex
	doneArgsForCall []struct {
		arg1 interface{}
	}
	ForgetStub        func(interface{})
	forgetMutex       sync.RWMutex
	forgetArgsForCall []struct {
		arg1 interface{}
	}
	GetStub        func() (interface{}, bool)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
	}
	getReturns struct {
		result1 interface{}
		result2 bool
	}
	getReturnsOnCall map[int]struct {
		result1 interface{}
		result2 bool
	}
	LenStub        func() int
	lenMutex       sync.RWMutex
	lenArgsForCall []struct {
	}
	lenReturns struct {
		result1 int
	}
	lenReturnsOnCall map[int]struct {
		result1 int
	}
	NumRequeuesStub        func(interface{}) int
	numRequeuesMutex       sync.RWMutex
	numRequeuesArgsForCall []struct {
		arg1 interface{}
	}
	numRequeuesReturns struct {
		result1 int
	}
	numRequeuesReturnsOnCall map[int]struct {
		result1 int
	}
	ShutDownStub        func()
	shutDownMutex       sync.RWMutex
	shutDownArgsForCall []struct {
	}
	ShuttingDownStub        func() bool
	shuttingDownMutex       sync.RWMutex
	shuttingDownArgsForCall []struct {
	}
	shuttingDownReturns struct {
		result1 bool
	}
	shuttingDownReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRateLimitingInterface) Add(arg1 interface{}) {
	fake.addMutex.Lock()
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("Add", []interface{}{arg1})
	fake.addMutex.Unlock()
	if fake.AddStub != nil {
		fake.AddStub(arg1)
	}
}

func (fake *FakeRateLimitingInterface) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *FakeRateLimitingInterface) AddCalls(stub func(interface{})) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *FakeRateLimitingInterface) AddArgsForCall(i int) interface{} {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRateLimitingInterface) AddAfter(arg1 interface{}, arg2 time.Duration) {
	fake.addAfterMutex.Lock()
	fake.addAfterArgsForCall = append(fake.addAfterArgsForCall, struct {
		arg1 interface{}
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AddAfter", []interface{}{arg1, arg2})
	fake.addAfterMutex.Unlock()
	if fake.AddAfterStub != nil {
		fake.AddAfterStub(arg1, arg2)
	}
}

func (fake *FakeRateLimitingInterface) AddAfterCallCount() int {
	fake.addAfterMutex.RLock()
	defer fake.addAfterMutex.RUnlock()
	return len(fake.addAfterArgsForCall)
}

func (fake *FakeRateLimitingInterface) AddAfterCalls(stub func(interface{}, time.Duration)) {
	fake.addAfterMutex.Lock()
	defer fake.addAfterMutex.Unlock()
	fake.AddAfterStub = stub
}

func (fake *FakeRateLimitingInterface) AddAfterArgsForCall(i int) (interface{}, time.Duration) {
	fake.addAfterMutex.RLock()
	defer fake.addAfterMutex.RUnlock()
	argsForCall := fake.addAfterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRateLimitingInterface) AddRateLimited(arg1 interface{}) {
	fake.addRateLimitedMutex.Lock()
	fake.addRateLimitedArgsForCall = append(fake.addRateLimitedArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("AddRateLimited", []interface{}{arg1})
	fake.addRateLimitedMutex.Unlock()
	if fake.AddRateLimitedStub != nil {
		fake.AddRateLimitedStub(arg1)
	}
}

func (fake *FakeRateLimitingInterface) AddRateLimitedCallCount() int {
	fake.addRateLimitedMutex.RLock()
	defer fake.addRateLimitedMutex.RUnlock()
	return len(fake.addRateLimitedArgsForCall)
}

func (fake *FakeRateLimitingInterface) AddRateLimitedCalls(stub func(interface{})) {
	fake.addRateLimitedMutex.Lock()
	defer fake.addRateLimitedMutex.Unlock()
	fake.AddRateLimitedStub = stub
}

func (fake *FakeRateLimitingInterface) AddRateLimitedArgsForCall(i int) interface{} {
	fake.addRateLimitedMutex.RLock()
	defer fake.addRateLimitedMutex.RUnlock()
	argsForCall := fake.addRateLimitedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRateLimitingInterface) Done(arg1 interface{}) {
	fake.doneMutex.Lock()
	fake.doneArgsForCall = append(fake.doneArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("Done", []interface{}{arg1})
	fake.doneMutex.Unlock()
	if fake.DoneStub != nil {
		fake.DoneStub(arg1)
	}
}

func (fake *FakeRateLimitingInterface) DoneCallCount() int {
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	return len(fake.doneArgsForCall)
}

func (fake *FakeRateLimitingInterface) DoneCalls(stub func(interface{})) {
	fake.doneMutex.Lock()
	defer fake.doneMutex.Unlock()
	fake.DoneStub = stub
}

func (fake *FakeRateLimitingInterface) DoneArgsForCall(i int) interface{} {
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	argsForCall := fake.doneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRateLimitingInterface) Forget(arg1 interface{}) {
	fake.forgetMutex.Lock()
	fake.forgetArgsForCall = append(fake.forgetArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("Forget", []interface{}{arg1})
	fake.forgetMutex.Unlock()
	if fake.ForgetStub != nil {
		fake.ForgetStub(arg1)
	}
}

func (fake *FakeRateLimitingInterface) ForgetCallCount() int {
	fake.forgetMutex.RLock()
	defer fake.forgetMutex.RUnlock()
	return len(fake.forgetArgsForCall)
}

func (fake *FakeRateLimitingInterface) ForgetCalls(stub func(interface{})) {
	fake.forgetMutex.Lock()
	defer fake.forgetMutex.Unlock()
	fake.ForgetStub = stub
}

func (fake *FakeRateLimitingInterface) ForgetArgsForCall(i int) interface{} {
	fake.forgetMutex.RLock()
	defer fake.forgetMutex.RUnlock()
	argsForCall := fake.forgetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRateLimitingInterface) Get() (interface{}, bool) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
	}{})
	fake.recordInvocation("Get", []interface{}{})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRateLimitingInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeRateLimitingInterface) GetCalls(stub func() (interface{}, bool)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeRateLimitingInterface) GetReturns(result1 interface{}, result2 bool) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 interface{}
		result2 bool
	}{result1, result2}
}

func (fake *FakeRateLimitingInterface) GetReturnsOnCall(i int, result1 interface{}, result2 bool) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 interface{}
			result2 bool
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 interface{}
		result2 bool
	}{result1, result2}
}

func (fake *FakeRateLimitingInterface) Len() int {
	fake.lenMutex.Lock()
	ret, specificReturn := fake.lenReturnsOnCall[len(fake.lenArgsForCall)]
	fake.lenArgsForCall = append(fake.lenArgsForCall, struct {
	}{})
	fake.recordInvocation("Len", []interface{}{})
	fake.lenMutex.Unlock()
	if fake.LenStub != nil {
		return fake.LenStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lenReturns
	return fakeReturns.result1
}

func (fake *FakeRateLimitingInterface) LenCallCount() int {
	fake.lenMutex.RLock()
	defer fake.lenMutex.RUnlock()
	return len(fake.lenArgsForCall)
}

func (fake *FakeRateLimitingInterface) LenCalls(stub func() int) {
	fake.lenMutex.Lock()
	defer fake.lenMutex.Unlock()
	fake.LenStub = stub
}

func (fake *FakeRateLimitingInterface) LenReturns(result1 int) {
	fake.lenMutex.Lock()
	defer fake.lenMutex.Unlock()
	fake.LenStub = nil
	fake.lenReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRateLimitingInterface) LenReturnsOnCall(i int, result1 int) {
	fake.lenMutex.Lock()
	defer fake.lenMutex.Unlock()
	fake.LenStub = nil
	if fake.lenReturnsOnCall == nil {
		fake.lenReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.lenReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRateLimitingInterface) NumRequeues(arg1 interface{}) int {
	fake.numRequeuesMutex.Lock()
	ret, specificReturn := fake.numRequeuesReturnsOnCall[len(fake.numRequeuesArgsForCall)]
	fake.numRequeuesArgsForCall = append(fake.numRequeuesArgsForCall, struct {
		arg1 interface{}
	}{arg1})
	fake.recordInvocation("NumRequeues", []interface{}{arg1})
	fake.numRequeuesMutex.Unlock()
	if fake.NumRequeuesStub != nil {
		return fake.NumRequeuesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.numRequeuesReturns
	return fakeReturns.result1
}

func (fake *FakeRateLimitingInterface) NumRequeuesCallCount() int {
	fake.numRequeuesMutex.RLock()
	defer fake.numRequeuesMutex.RUnlock()
	return len(fake.numRequeuesArgsForCall)
}

func (fake *FakeRateLimitingInterface) NumRequeuesCalls(stub func(interface{}) int) {
	fake.numRequeuesMutex.Lock()
	defer fake.numRequeuesMutex.Unlock()
	fake.NumRequeuesStub = stub
}

func (fake *FakeRateLimitingInterface) NumRequeuesArgsForCall(i int) interface{} {
	fake.numRequeuesMutex.RLock()
	defer fake.numRequeuesMutex.RUnlock()
	argsForCall := fake.numRequeuesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRateLimitingInterface) NumRequeuesReturns(result1 int) {
	fake.numRequeuesMutex.Lock()
	defer fake.numRequeuesMutex.Unlock()
	fake.NumRequeuesStub = nil
	fake.numRequeuesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeRateLimitingInterface) NumRequeuesReturnsOnCall(i int, result1 int) {
	fake.numRequeuesMutex.Lock()
	defer fake.numRequeuesMutex.Unlock()
	fake.NumRequeuesStub = nil
	if fake.numRequeuesReturnsOnCall == nil {
		fake.numRequeuesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numRequeuesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeRateLimitingInterface) ShutDown() {
	fake.shutDownMutex.Lock()
	fake.shutDownArgsForCall = append(fake.shutDownArgsForCall, struct {
	}{})
	fake.recordInvocation("ShutDown", []interface{}{})
	fake.shutDownMutex.Unlock()
	if fake.ShutDownStub != nil {
		fake.ShutDownStub()
	}
}

func (fake *FakeRateLimitingInterface) ShutDownCallCount() int {
	fake.shutDownMutex.RLock()
	defer fake.shutDownMutex.RUnlock()
	return len(fake.shutDownArgsForCall)
}

func (fake *FakeRateLimitingInterface) ShutDownCalls(stub func()) {
	fake.shutDownMutex.Lock()
	defer fake.shutDownMutex.Unlock()
	fake.ShutDownStub = stub
}

func (fake *FakeRateLimitingInterface) ShuttingDown() bool {
	fake.shuttingDownMutex.Lock()
	ret, specificReturn := fake.shuttingDownReturnsOnCall[len(fake.shuttingDownArgsForCall)]
	fake.shuttingDownArgsForCall = append(fake.shuttingDownArgsForCall, struct {
	}{})
	fake.recordInvocation("ShuttingDown", []interface{}{})
	fake.shuttingDownMutex.Unlock()
	if fake.ShuttingDownStub != nil {
		return fake.ShuttingDownStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.shuttingDownReturns
	return fakeReturns.result1
}

func (fake *FakeRateLimitingInterface) ShuttingDownCallCount() int {
	fake.shuttingDownMutex.RLock()
	defer fake.shuttingDownMutex.RUnlock()
	return len(fake.shuttingDownArgsForCall)
}

func (fake *FakeRateLimitingInterface) ShuttingDownCalls(stub func() bool) {
	fake.shuttingDownMutex.Lock()
	defer fake.shuttingDownMutex.Unlock()
	fake.ShuttingDownStub = stub
}

func (fake *FakeRateLimitingInterface) ShuttingDownReturns(result1 bool) {
	fake.shuttingDownMutex.Lock()
	defer fake.shuttingDownMutex.Unlock()
	fake.ShuttingDownStub = nil
	fake.shuttingDownReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRateLimitingInterface) ShuttingDownReturnsOnCall(i int, result1 bool) {
	fake.shuttingDownMutex.Lock()
	defer fake.shuttingDownMutex.Unlock()
	fake.ShuttingDownStub = nil
	if fake.shuttingDownReturnsOnCall == nil {
		fake.shuttingDownReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.shuttingDownReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRateLimitingInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.addAfterMutex.RLock()
	defer fake.addAfterMutex.RUnlock()
	fake.addRateLimitedMutex.RLock()
	defer fake.addRateLimitedMutex.RUnlock()
	fake.doneMutex.RLock()
	defer fake.doneMutex.RUnlock()
	fake.forgetMutex.RLock()
	defer fake.forgetMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.lenMutex.RLock()
	defer fake.lenMutex.RUnlock()
	fake.numRequeuesMutex.RLock()
	defer fake.numRequeuesMutex.RUnlock()
	fake.shutDownMutex.RLock()
	defer fake.shutDownMutex.RUnlock()
	fake.shuttingDownMutex.RLock()
	defer fake.shuttingDownMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRateLimitingInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ workqueue.RateLimitingInterface = new(FakeRateLimitingInterface)
